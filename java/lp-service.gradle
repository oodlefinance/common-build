// Shared gradle script for java services using spring boot 3.x and dependency locking
// with additional config for a second test task - integrationTest, using src/intTest

import java.nio.file.Files
import java.text.SimpleDateFormat
import java.util.jar.JarFile
import java.util.zip.CRC32
import java.util.jar.JarOutputStream
import java.util.jar.JarEntry
import java.util.zip.ZipEntry
import org.gradle.api.artifacts.transform.TransformParameters

buildscript {
    ext {
        springBootVersion = '3.+' // Version used for framework dependencies
        // Plugin versions
        dependencyCheckVersion = '7.+'
        versionsPluginVersion = '+'
        // Versions for dependencies included in this script
        lpBomVersion = '1.+'
        lombokVersion = '1.+'
        oodleLoggingVersion = '3.+'
        logstashEncoderVersion = '7.+'
    }
    // Repository block for sourcing plugins
    repositories {
        maven {
            url = "https://${codeartifactDomain}-${awsBuildAccountId}.d.codeartifact.eu-west-1.amazonaws.com/maven/oodle-maven-repo/"
            credentials {
                username = "${codeartifactUser}"
                password = "${codeartifactToken}"
            }
        }
    }
    dependencies {
        classpath "org.springframework.boot:spring-boot-gradle-plugin:3.4.1"
        classpath "org.sonarsource.scanner.gradle:sonarqube-gradle-plugin:6.0.1.5171"
    }
}

apply plugin: 'java'
apply plugin: 'jacoco'
// In order to provide plugins for other projects sourcing this script, we must specify the plugins by type
// See https://blog.mrhaki.com/2015/10/gradle-goodness-apply-external-script.html
apply plugin: org.springframework.boot.gradle.plugin.SpringBootPlugin
apply plugin: org.sonarqube.gradle.SonarQubePlugin

// Repository block for sourcing dependencies
repositories {
    maven {
        url = "https://${codeartifactDomain}-${awsBuildAccountId}.d.codeartifact.eu-west-1.amazonaws.com/maven/oodle-maven-repo/"
        credentials {
            username = "${codeartifactUser}"
            password = "${codeartifactToken}"
        }
    }
}

dependencyLocking {
    // Enable locking of dependency versions using '--write-locks' to generate a `gradle.lockfile`
    lockAllConfigurations()
}

dependencies {
    implementation platform("com.oodlefinance.loanprocessing:lp-service-bom:${lpBomVersion}")

    annotationProcessor "org.springframework.boot:spring-boot-configuration-processor:${springBootVersion}"

    compileOnly "org.projectlombok:lombok:${lombokVersion}"
    annotationProcessor "org.projectlombok:lombok:${lombokVersion}"
    testCompileOnly "org.projectlombok:lombok:${lombokVersion}"
    testAnnotationProcessor "org.projectlombok:lombok:${lombokVersion}"

    implementation "net.logstash.logback:logstash-logback-encoder:${logstashEncoderVersion}"
    implementation "com.oodlefinance:logging:${oodleLoggingVersion}"

}

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(javaVersion)
    }
}

// Use the PROJECT_VERSION var if set (EG by CI), or fall back to current timestamp
project.version = System.getenv('PROJECT_VERSION') ?:
        new SimpleDateFormat("'v'yyyyMMddHHmmss").format(new Date())


configurations {
    developmentOnly
    runtimeClasspath {
        extendsFrom developmentOnly
    }
    intTestImplementation.extendsFrom testImplementation
    intTestRuntimeOnly.extendsFrom testRuntimeOnly
    // Exclude snakeyaml entirely - we're not parsing yaml and we see repeated security issues with it
    all*.exclude group: 'org.yaml', module:'snakeyaml'
}

bootJar {
    archiveFileName = "${rootProject.name.toLowerCase()}.jar"
    manifest {
        attributes(
                'Implementation-Version': project.version,
                'Bundle-SymbolicName': project.group,
                'Git-commit-hash': "git rev-parse --verify HEAD".execute().text.trim()
        )
    }
}

test {
    useJUnitPlatform()
    systemProperty 'spring.profiles.active', 'test'
    testLogging {
        events "passed", "skipped", "failed"
    }
}

sourceSets {
    main {
        java.srcDirs += 'src/main/java'
    }
    test {
        java.srcDirs += 'src/test/java'
    }
    intTest {
        java.srcDir "$projectDir/src/intTest/java"
        resources.srcDir file('src/main/resources')
        resources.srcDir file('src/intTest/resources')
        compileClasspath += main.output + test.output
        runtimeClasspath += main.output + test.output
    }
}

task integrationTest(type: Test) {
    dependsOn bootJar
    description = 'Runs integration tests.'
    group = 'verification'

    testClassesDirs = sourceSets.intTest.output.classesDirs
    classpath = sourceSets.intTest.runtimeClasspath
}

tasks.named('integrationTest') {
    useJUnitPlatform()
    testLogging {
        events "passed", "skipped", "failed"
        showStandardStreams = true
    }
    systemProperty 'spring.profiles.active', 'intTest'
    environment "TESTCONTAINERS_CHECKS_DISABLE", "true" // Speeds up startup and prevents macOS issue with freezing container
    environment "TESTCONTAINERS_REUSE_ENABLE", "true" // Reuse containers between tests when they're configured `withReuse`
}

task cleanContainers(type: Exec) {
    commandLine 'sh', '-c', 'docker rm -f $(docker ps -aq --filter "label=org.testcontainers")'
}

processIntTestResources {
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}

/**
 * Our fat jar includes nested jars in BOOT-INF/lib. This transform will extract the nested jars,
 * remove META-INF/maven/, and then repackage the jar.
 * This is necessary to avoid AWS Inspector triggering on dependencies listed in those maven files -
 * We'd rather inspector only check the third-party code actually included as a nested jar.
 *
 * A better solution to this issue might be to split up our fat jar into multiple layers,
 * which might help us define an inspector suppression rule more easily.
 */
abstract class RemoveMavenMetaInfTransform implements TransformAction<TransformParameters.None> {
    @InputArtifact
    abstract Provider<FileSystemLocation> getInputArtifact()

    @Override
    void transform(TransformOutputs outputs) {
        File inputJar = getInputArtifact().get().asFile
        File outputJar = outputs.file("cleaned-${inputJar.name}")
        println "Removing META-INF/maven from ${inputJar.name}"
        def jarFile = new JarFile(inputJar)
        outputJar.withOutputStream { os ->
            def jos = new JarOutputStream(os)
            jarFile.entries().each { entry ->
                if (!entry.name.startsWith("META-INF/maven/")) {
                    byte[] entryBytes = jarFile.getInputStream(entry).bytes
                    def newEntry = new JarEntry(entry.name)
                    newEntry.method = ZipEntry.DEFLATED
                    newEntry.size = entryBytes.length
                    def crc = new CRC32()
                    crc.update(entryBytes)
                    newEntry.crc = crc.value
                    jos.putNextEntry(newEntry)
                    jos.write(entryBytes)
                    jos.closeEntry()
                }
            }
            jos.close()
        }
        jarFile.close()
    }
}

dependencies {
    registerTransform(RemoveMavenMetaInfTransform) {
        from.attribute(Attribute.of("artifactType", String), "jar")
        to.attribute(Attribute.of("artifactType", String), "cleaned-jar")
    }
}

configurations {
    runtimeClasspath {
        attributes {
            attribute(Attribute.of("artifactType", String), "cleaned-jar")
        }
    }
}

jacocoTestReport {
    // Jacoco config to ensure coverage from integration tests are included
    dependsOn test, integrationTest

    reports {
        xml.required = true
        html.required = true
    }

    executionData fileTree(dir: "$buildDir/jacoco", include: "**/*.exec") // Include all JaCoCo execution data
}

sonar {
    properties {
        property 'sonar.organization', "${sonarOrganization}"
        property "sonar.host.url", "${sonarHost}"
        property 'sonar.coverage.jacoco.xmlReportPaths', jacocoTestReport.reports.xml.outputLocation.get().asFile.absolutePath
    }
}
